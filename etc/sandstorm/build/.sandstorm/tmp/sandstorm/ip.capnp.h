// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: ip.capnp

#ifndef CAPNP_INCLUDED_f44732d435305f86_
#define CAPNP_INCLUDED_f44732d435305f86_

#include <capnp/generated-header-support.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#if CAPNP_VERSION != 6000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "supervisor.capnp.h"
#include "util.capnp.h"

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(a982576b7a2a2040);
CAPNP_DECLARE_SCHEMA(dd1700c1eb725eb4);
CAPNP_DECLARE_SCHEMA(b57bd5aef30c4b61);
CAPNP_DECLARE_SCHEMA(9d5f1f6efcf7bbc4);
CAPNP_DECLARE_SCHEMA(d14a2ec2bad45f69);
CAPNP_DECLARE_SCHEMA(eeb98f9937d32c0b);
CAPNP_DECLARE_SCHEMA(e32c506ee93ed6fa);
CAPNP_DECLARE_SCHEMA(fd226ae4c6bd2b1e);
CAPNP_DECLARE_SCHEMA(9381253786627ecf);
CAPNP_DECLARE_SCHEMA(a1d8815a262abc49);
CAPNP_DECLARE_SCHEMA(cb83a480981bc290);
CAPNP_DECLARE_SCHEMA(905dd76b298b3130);
CAPNP_DECLARE_SCHEMA(ed10beb11e7383e9);
CAPNP_DECLARE_SCHEMA(d77df9f44cfcde33);
CAPNP_DECLARE_SCHEMA(b62b02486ebe26ed);
CAPNP_DECLARE_SCHEMA(f53aa3a93e49003b);
CAPNP_DECLARE_SCHEMA(eab20e1af07806b4);
CAPNP_DECLARE_SCHEMA(8a60e53250a32321);
CAPNP_DECLARE_SCHEMA(cdd1222d14073645);
CAPNP_DECLARE_SCHEMA(c6212e1217d001ce);
CAPNP_DECLARE_SCHEMA(c6ca13f7c8dbd102);
CAPNP_DECLARE_SCHEMA(8e43fd8e213b1811);
CAPNP_DECLARE_SCHEMA(856e71a6a4f22bba);
CAPNP_DECLARE_SCHEMA(a5b3215660e038f2);
CAPNP_DECLARE_SCHEMA(cf43ebe6a5a6f1b4);

}  // namespace schemas
}  // namespace capnp

namespace sandstorm {

struct IpNetwork {
  IpNetwork() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct GetRemoteHostParams;
  struct GetRemoteHostResults;
  struct GetRemoteHostByNameParams;
  struct GetRemoteHostByNameResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(a982576b7a2a2040)
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
  };
  #endif  // !CAPNP_LITE
};

struct IpNetwork::GetRemoteHostParams {
  GetRemoteHostParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dd1700c1eb725eb4, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct IpNetwork::GetRemoteHostResults {
  GetRemoteHostResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b57bd5aef30c4b61, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct IpNetwork::GetRemoteHostByNameParams {
  GetRemoteHostByNameParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9d5f1f6efcf7bbc4, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct IpNetwork::GetRemoteHostByNameResults {
  GetRemoteHostByNameResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d14a2ec2bad45f69, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct IpAddress {
  IpAddress() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(eeb98f9937d32c0b, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct IpInterface {
  IpInterface() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct ListenTcpParams;
  struct ListenTcpResults;
  struct ListenUdpParams;
  struct ListenUdpResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(e32c506ee93ed6fa)
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
  };
  #endif  // !CAPNP_LITE
};

struct IpInterface::ListenTcpParams {
  ListenTcpParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fd226ae4c6bd2b1e, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct IpInterface::ListenTcpResults {
  ListenTcpResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9381253786627ecf, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct IpInterface::ListenUdpParams {
  ListenUdpParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a1d8815a262abc49, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct IpInterface::ListenUdpResults {
  ListenUdpResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cb83a480981bc290, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct IpRemoteHost {
  IpRemoteHost() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct GetTcpPortParams;
  struct GetTcpPortResults;
  struct GetUdpPortParams;
  struct GetUdpPortResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(905dd76b298b3130)
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
  };
  #endif  // !CAPNP_LITE
};

struct IpRemoteHost::GetTcpPortParams {
  GetTcpPortParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ed10beb11e7383e9, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct IpRemoteHost::GetTcpPortResults {
  GetTcpPortResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d77df9f44cfcde33, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct IpRemoteHost::GetUdpPortParams {
  GetUdpPortParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b62b02486ebe26ed, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct IpRemoteHost::GetUdpPortResults {
  GetUdpPortResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f53aa3a93e49003b, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct TcpPort {
  TcpPort() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct ConnectParams;
  struct ConnectResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(eab20e1af07806b4)
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
  };
  #endif  // !CAPNP_LITE
};

struct TcpPort::ConnectParams {
  ConnectParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8a60e53250a32321, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct TcpPort::ConnectResults {
  ConnectResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cdd1222d14073645, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct UdpPort {
  UdpPort() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct SendParams;
  struct SendResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(c6212e1217d001ce)
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
  };
  #endif  // !CAPNP_LITE
};

struct UdpPort::SendParams {
  SendParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c6ca13f7c8dbd102, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct UdpPort::SendResults {
  SendResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8e43fd8e213b1811, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct IpPortPowerboxMetadata {
  IpPortPowerboxMetadata() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(856e71a6a4f22bba, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
    #endif  // !CAPNP_LITE
  };
};

struct PersistentIpNetwork {
  PersistentIpNetwork() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE


  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(a5b3215660e038f2)
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
  };
  #endif  // !CAPNP_LITE
};

struct PersistentIpInterface {
  PersistentIpInterface() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE


  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(cf43ebe6a5a6f1b4)
    static constexpr ::capnp::_::RawBrandedSchema const* brand = &schema->defaultBrand;
  };
  #endif  // !CAPNP_LITE
};

// =======================================================================================

#if !CAPNP_LITE
class IpNetwork::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef IpNetwork Calls;
  typedef IpNetwork Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::sandstorm::IpNetwork::GetRemoteHostParams,  ::sandstorm::IpNetwork::GetRemoteHostResults> getRemoteHostRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::sandstorm::IpNetwork::GetRemoteHostByNameParams,  ::sandstorm::IpNetwork::GetRemoteHostByNameResults> getRemoteHostByNameRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class IpNetwork::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef IpNetwork Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::sandstorm::IpNetwork::GetRemoteHostParams GetRemoteHostParams;
  typedef  ::sandstorm::IpNetwork::GetRemoteHostResults GetRemoteHostResults;
  typedef ::capnp::CallContext<GetRemoteHostParams, GetRemoteHostResults> GetRemoteHostContext;
  virtual ::kj::Promise<void> getRemoteHost(GetRemoteHostContext context);
  typedef  ::sandstorm::IpNetwork::GetRemoteHostByNameParams GetRemoteHostByNameParams;
  typedef  ::sandstorm::IpNetwork::GetRemoteHostByNameResults GetRemoteHostByNameResults;
  typedef ::capnp::CallContext<GetRemoteHostByNameParams, GetRemoteHostByNameResults> GetRemoteHostByNameContext;
  virtual ::kj::Promise<void> getRemoteHostByName(GetRemoteHostByNameContext context);

  inline  ::sandstorm::IpNetwork::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::sandstorm::IpNetwork>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class IpNetwork::GetRemoteHostParams::Reader {
public:
  typedef GetRemoteHostParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasAddress() const;
  inline  ::sandstorm::IpAddress::Reader getAddress() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IpNetwork::GetRemoteHostParams::Builder {
public:
  typedef GetRemoteHostParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasAddress();
  inline  ::sandstorm::IpAddress::Builder getAddress();
  inline void setAddress( ::sandstorm::IpAddress::Reader value);
  inline  ::sandstorm::IpAddress::Builder initAddress();
  inline void adoptAddress(::capnp::Orphan< ::sandstorm::IpAddress>&& value);
  inline ::capnp::Orphan< ::sandstorm::IpAddress> disownAddress();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IpNetwork::GetRemoteHostParams::Pipeline {
public:
  typedef GetRemoteHostParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::sandstorm::IpAddress::Pipeline getAddress();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IpNetwork::GetRemoteHostResults::Reader {
public:
  typedef GetRemoteHostResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasHost() const;
#if !CAPNP_LITE
  inline  ::sandstorm::IpRemoteHost::Client getHost() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IpNetwork::GetRemoteHostResults::Builder {
public:
  typedef GetRemoteHostResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHost();
#if !CAPNP_LITE
  inline  ::sandstorm::IpRemoteHost::Client getHost();
  inline void setHost( ::sandstorm::IpRemoteHost::Client&& value);
  inline void setHost( ::sandstorm::IpRemoteHost::Client& value);
  inline void adoptHost(::capnp::Orphan< ::sandstorm::IpRemoteHost>&& value);
  inline ::capnp::Orphan< ::sandstorm::IpRemoteHost> disownHost();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IpNetwork::GetRemoteHostResults::Pipeline {
public:
  typedef GetRemoteHostResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::sandstorm::IpRemoteHost::Client getHost();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IpNetwork::GetRemoteHostByNameParams::Reader {
public:
  typedef GetRemoteHostByNameParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasAddress() const;
  inline  ::capnp::Text::Reader getAddress() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IpNetwork::GetRemoteHostByNameParams::Builder {
public:
  typedef GetRemoteHostByNameParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasAddress();
  inline  ::capnp::Text::Builder getAddress();
  inline void setAddress( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initAddress(unsigned int size);
  inline void adoptAddress(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownAddress();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IpNetwork::GetRemoteHostByNameParams::Pipeline {
public:
  typedef GetRemoteHostByNameParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IpNetwork::GetRemoteHostByNameResults::Reader {
public:
  typedef GetRemoteHostByNameResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasHost() const;
#if !CAPNP_LITE
  inline  ::sandstorm::IpRemoteHost::Client getHost() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IpNetwork::GetRemoteHostByNameResults::Builder {
public:
  typedef GetRemoteHostByNameResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHost();
#if !CAPNP_LITE
  inline  ::sandstorm::IpRemoteHost::Client getHost();
  inline void setHost( ::sandstorm::IpRemoteHost::Client&& value);
  inline void setHost( ::sandstorm::IpRemoteHost::Client& value);
  inline void adoptHost(::capnp::Orphan< ::sandstorm::IpRemoteHost>&& value);
  inline ::capnp::Orphan< ::sandstorm::IpRemoteHost> disownHost();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IpNetwork::GetRemoteHostByNameResults::Pipeline {
public:
  typedef GetRemoteHostByNameResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::sandstorm::IpRemoteHost::Client getHost();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IpAddress::Reader {
public:
  typedef IpAddress Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getLower64() const;

  inline  ::uint64_t getUpper64() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IpAddress::Builder {
public:
  typedef IpAddress Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getLower64();
  inline void setLower64( ::uint64_t value);

  inline  ::uint64_t getUpper64();
  inline void setUpper64( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IpAddress::Pipeline {
public:
  typedef IpAddress Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class IpInterface::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef IpInterface Calls;
  typedef IpInterface Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::sandstorm::IpInterface::ListenTcpParams,  ::sandstorm::IpInterface::ListenTcpResults> listenTcpRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::sandstorm::IpInterface::ListenUdpParams,  ::sandstorm::IpInterface::ListenUdpResults> listenUdpRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class IpInterface::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef IpInterface Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::sandstorm::IpInterface::ListenTcpParams ListenTcpParams;
  typedef  ::sandstorm::IpInterface::ListenTcpResults ListenTcpResults;
  typedef ::capnp::CallContext<ListenTcpParams, ListenTcpResults> ListenTcpContext;
  virtual ::kj::Promise<void> listenTcp(ListenTcpContext context);
  typedef  ::sandstorm::IpInterface::ListenUdpParams ListenUdpParams;
  typedef  ::sandstorm::IpInterface::ListenUdpResults ListenUdpResults;
  typedef ::capnp::CallContext<ListenUdpParams, ListenUdpResults> ListenUdpContext;
  virtual ::kj::Promise<void> listenUdp(ListenUdpContext context);

  inline  ::sandstorm::IpInterface::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::sandstorm::IpInterface>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class IpInterface::ListenTcpParams::Reader {
public:
  typedef ListenTcpParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getPortNum() const;

  inline bool hasPort() const;
#if !CAPNP_LITE
  inline  ::sandstorm::TcpPort::Client getPort() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IpInterface::ListenTcpParams::Builder {
public:
  typedef ListenTcpParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getPortNum();
  inline void setPortNum( ::uint16_t value);

  inline bool hasPort();
#if !CAPNP_LITE
  inline  ::sandstorm::TcpPort::Client getPort();
  inline void setPort( ::sandstorm::TcpPort::Client&& value);
  inline void setPort( ::sandstorm::TcpPort::Client& value);
  inline void adoptPort(::capnp::Orphan< ::sandstorm::TcpPort>&& value);
  inline ::capnp::Orphan< ::sandstorm::TcpPort> disownPort();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IpInterface::ListenTcpParams::Pipeline {
public:
  typedef ListenTcpParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::sandstorm::TcpPort::Client getPort();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IpInterface::ListenTcpResults::Reader {
public:
  typedef ListenTcpResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasHandle() const;
#if !CAPNP_LITE
  inline  ::sandstorm::Handle::Client getHandle() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IpInterface::ListenTcpResults::Builder {
public:
  typedef ListenTcpResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHandle();
#if !CAPNP_LITE
  inline  ::sandstorm::Handle::Client getHandle();
  inline void setHandle( ::sandstorm::Handle::Client&& value);
  inline void setHandle( ::sandstorm::Handle::Client& value);
  inline void adoptHandle(::capnp::Orphan< ::sandstorm::Handle>&& value);
  inline ::capnp::Orphan< ::sandstorm::Handle> disownHandle();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IpInterface::ListenTcpResults::Pipeline {
public:
  typedef ListenTcpResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::sandstorm::Handle::Client getHandle();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IpInterface::ListenUdpParams::Reader {
public:
  typedef ListenUdpParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getPortNum() const;

  inline bool hasPort() const;
#if !CAPNP_LITE
  inline  ::sandstorm::UdpPort::Client getPort() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IpInterface::ListenUdpParams::Builder {
public:
  typedef ListenUdpParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getPortNum();
  inline void setPortNum( ::uint16_t value);

  inline bool hasPort();
#if !CAPNP_LITE
  inline  ::sandstorm::UdpPort::Client getPort();
  inline void setPort( ::sandstorm::UdpPort::Client&& value);
  inline void setPort( ::sandstorm::UdpPort::Client& value);
  inline void adoptPort(::capnp::Orphan< ::sandstorm::UdpPort>&& value);
  inline ::capnp::Orphan< ::sandstorm::UdpPort> disownPort();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IpInterface::ListenUdpParams::Pipeline {
public:
  typedef ListenUdpParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::sandstorm::UdpPort::Client getPort();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IpInterface::ListenUdpResults::Reader {
public:
  typedef ListenUdpResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasHandle() const;
#if !CAPNP_LITE
  inline  ::sandstorm::Handle::Client getHandle() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IpInterface::ListenUdpResults::Builder {
public:
  typedef ListenUdpResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHandle();
#if !CAPNP_LITE
  inline  ::sandstorm::Handle::Client getHandle();
  inline void setHandle( ::sandstorm::Handle::Client&& value);
  inline void setHandle( ::sandstorm::Handle::Client& value);
  inline void adoptHandle(::capnp::Orphan< ::sandstorm::Handle>&& value);
  inline ::capnp::Orphan< ::sandstorm::Handle> disownHandle();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IpInterface::ListenUdpResults::Pipeline {
public:
  typedef ListenUdpResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::sandstorm::Handle::Client getHandle();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class IpRemoteHost::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef IpRemoteHost Calls;
  typedef IpRemoteHost Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::sandstorm::IpRemoteHost::GetTcpPortParams,  ::sandstorm::IpRemoteHost::GetTcpPortResults> getTcpPortRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::sandstorm::IpRemoteHost::GetUdpPortParams,  ::sandstorm::IpRemoteHost::GetUdpPortResults> getUdpPortRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class IpRemoteHost::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef IpRemoteHost Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::sandstorm::IpRemoteHost::GetTcpPortParams GetTcpPortParams;
  typedef  ::sandstorm::IpRemoteHost::GetTcpPortResults GetTcpPortResults;
  typedef ::capnp::CallContext<GetTcpPortParams, GetTcpPortResults> GetTcpPortContext;
  virtual ::kj::Promise<void> getTcpPort(GetTcpPortContext context);
  typedef  ::sandstorm::IpRemoteHost::GetUdpPortParams GetUdpPortParams;
  typedef  ::sandstorm::IpRemoteHost::GetUdpPortResults GetUdpPortResults;
  typedef ::capnp::CallContext<GetUdpPortParams, GetUdpPortResults> GetUdpPortContext;
  virtual ::kj::Promise<void> getUdpPort(GetUdpPortContext context);

  inline  ::sandstorm::IpRemoteHost::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::sandstorm::IpRemoteHost>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class IpRemoteHost::GetTcpPortParams::Reader {
public:
  typedef GetTcpPortParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getPortNum() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IpRemoteHost::GetTcpPortParams::Builder {
public:
  typedef GetTcpPortParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getPortNum();
  inline void setPortNum( ::uint16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IpRemoteHost::GetTcpPortParams::Pipeline {
public:
  typedef GetTcpPortParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IpRemoteHost::GetTcpPortResults::Reader {
public:
  typedef GetTcpPortResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasPort() const;
#if !CAPNP_LITE
  inline  ::sandstorm::TcpPort::Client getPort() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IpRemoteHost::GetTcpPortResults::Builder {
public:
  typedef GetTcpPortResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPort();
#if !CAPNP_LITE
  inline  ::sandstorm::TcpPort::Client getPort();
  inline void setPort( ::sandstorm::TcpPort::Client&& value);
  inline void setPort( ::sandstorm::TcpPort::Client& value);
  inline void adoptPort(::capnp::Orphan< ::sandstorm::TcpPort>&& value);
  inline ::capnp::Orphan< ::sandstorm::TcpPort> disownPort();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IpRemoteHost::GetTcpPortResults::Pipeline {
public:
  typedef GetTcpPortResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::sandstorm::TcpPort::Client getPort();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IpRemoteHost::GetUdpPortParams::Reader {
public:
  typedef GetUdpPortParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getPortNum() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IpRemoteHost::GetUdpPortParams::Builder {
public:
  typedef GetUdpPortParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getPortNum();
  inline void setPortNum( ::uint16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IpRemoteHost::GetUdpPortParams::Pipeline {
public:
  typedef GetUdpPortParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IpRemoteHost::GetUdpPortResults::Reader {
public:
  typedef GetUdpPortResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasPort() const;
#if !CAPNP_LITE
  inline  ::sandstorm::UdpPort::Client getPort() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IpRemoteHost::GetUdpPortResults::Builder {
public:
  typedef GetUdpPortResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPort();
#if !CAPNP_LITE
  inline  ::sandstorm::UdpPort::Client getPort();
  inline void setPort( ::sandstorm::UdpPort::Client&& value);
  inline void setPort( ::sandstorm::UdpPort::Client& value);
  inline void adoptPort(::capnp::Orphan< ::sandstorm::UdpPort>&& value);
  inline ::capnp::Orphan< ::sandstorm::UdpPort> disownPort();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IpRemoteHost::GetUdpPortResults::Pipeline {
public:
  typedef GetUdpPortResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::sandstorm::UdpPort::Client getPort();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class TcpPort::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef TcpPort Calls;
  typedef TcpPort Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::sandstorm::TcpPort::ConnectParams,  ::sandstorm::TcpPort::ConnectResults> connectRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class TcpPort::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef TcpPort Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::sandstorm::TcpPort::ConnectParams ConnectParams;
  typedef  ::sandstorm::TcpPort::ConnectResults ConnectResults;
  typedef ::capnp::CallContext<ConnectParams, ConnectResults> ConnectContext;
  virtual ::kj::Promise<void> connect(ConnectContext context);

  inline  ::sandstorm::TcpPort::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::sandstorm::TcpPort>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class TcpPort::ConnectParams::Reader {
public:
  typedef ConnectParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasDownstream() const;
#if !CAPNP_LITE
  inline  ::sandstorm::ByteStream::Client getDownstream() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TcpPort::ConnectParams::Builder {
public:
  typedef ConnectParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasDownstream();
#if !CAPNP_LITE
  inline  ::sandstorm::ByteStream::Client getDownstream();
  inline void setDownstream( ::sandstorm::ByteStream::Client&& value);
  inline void setDownstream( ::sandstorm::ByteStream::Client& value);
  inline void adoptDownstream(::capnp::Orphan< ::sandstorm::ByteStream>&& value);
  inline ::capnp::Orphan< ::sandstorm::ByteStream> disownDownstream();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TcpPort::ConnectParams::Pipeline {
public:
  typedef ConnectParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::sandstorm::ByteStream::Client getDownstream();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TcpPort::ConnectResults::Reader {
public:
  typedef ConnectResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasUpstream() const;
#if !CAPNP_LITE
  inline  ::sandstorm::ByteStream::Client getUpstream() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TcpPort::ConnectResults::Builder {
public:
  typedef ConnectResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasUpstream();
#if !CAPNP_LITE
  inline  ::sandstorm::ByteStream::Client getUpstream();
  inline void setUpstream( ::sandstorm::ByteStream::Client&& value);
  inline void setUpstream( ::sandstorm::ByteStream::Client& value);
  inline void adoptUpstream(::capnp::Orphan< ::sandstorm::ByteStream>&& value);
  inline ::capnp::Orphan< ::sandstorm::ByteStream> disownUpstream();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TcpPort::ConnectResults::Pipeline {
public:
  typedef ConnectResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::sandstorm::ByteStream::Client getUpstream();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class UdpPort::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef UdpPort Calls;
  typedef UdpPort Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::sandstorm::UdpPort::SendParams,  ::sandstorm::UdpPort::SendResults> sendRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class UdpPort::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef UdpPort Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::sandstorm::UdpPort::SendParams SendParams;
  typedef  ::sandstorm::UdpPort::SendResults SendResults;
  typedef ::capnp::CallContext<SendParams, SendResults> SendContext;
  virtual ::kj::Promise<void> send(SendContext context);

  inline  ::sandstorm::UdpPort::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::sandstorm::UdpPort>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class UdpPort::SendParams::Reader {
public:
  typedef SendParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline bool hasMessage() const;
  inline  ::capnp::Data::Reader getMessage() const;

  inline bool hasReturnPort() const;
#if !CAPNP_LITE
  inline  ::sandstorm::UdpPort::Client getReturnPort() const;
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class UdpPort::SendParams::Builder {
public:
  typedef SendParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMessage();
  inline  ::capnp::Data::Builder getMessage();
  inline void setMessage( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initMessage(unsigned int size);
  inline void adoptMessage(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownMessage();

  inline bool hasReturnPort();
#if !CAPNP_LITE
  inline  ::sandstorm::UdpPort::Client getReturnPort();
  inline void setReturnPort( ::sandstorm::UdpPort::Client&& value);
  inline void setReturnPort( ::sandstorm::UdpPort::Client& value);
  inline void adoptReturnPort(::capnp::Orphan< ::sandstorm::UdpPort>&& value);
  inline ::capnp::Orphan< ::sandstorm::UdpPort> disownReturnPort();
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class UdpPort::SendParams::Pipeline {
public:
  typedef SendParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::sandstorm::UdpPort::Client getReturnPort();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class UdpPort::SendResults::Reader {
public:
  typedef SendResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class UdpPort::SendResults::Builder {
public:
  typedef SendResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class UdpPort::SendResults::Pipeline {
public:
  typedef SendResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IpPortPowerboxMetadata::Reader {
public:
  typedef IpPortPowerboxMetadata Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand);
  }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getPreferredPortNum() const;

  inline bool hasPreferredHost() const;
  inline  ::capnp::Text::Reader getPreferredHost() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IpPortPowerboxMetadata::Builder {
public:
  typedef IpPortPowerboxMetadata Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint16_t getPreferredPortNum();
  inline void setPreferredPortNum( ::uint16_t value);

  inline bool hasPreferredHost();
  inline  ::capnp::Text::Builder getPreferredHost();
  inline void setPreferredHost( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initPreferredHost(unsigned int size);
  inline void adoptPreferredHost(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownPreferredHost();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IpPortPowerboxMetadata::Pipeline {
public:
  typedef IpPortPowerboxMetadata Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class PersistentIpNetwork::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::sandstorm::IpNetwork::Client,
      public virtual  ::sandstorm::SystemPersistent::Client {
public:
  typedef PersistentIpNetwork Calls;
  typedef PersistentIpNetwork Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);


protected:
  Client() = default;
};

class PersistentIpNetwork::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::sandstorm::IpNetwork::Server,
      public virtual  ::sandstorm::SystemPersistent::Server {
public:
  typedef PersistentIpNetwork Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:

  inline  ::sandstorm::PersistentIpNetwork::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::sandstorm::PersistentIpNetwork>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class PersistentIpInterface::Client
    : public virtual ::capnp::Capability::Client,
      public virtual  ::sandstorm::IpInterface::Client,
      public virtual  ::sandstorm::SystemPersistent::Client {
public:
  typedef PersistentIpInterface Calls;
  typedef PersistentIpInterface Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);


protected:
  Client() = default;
};

class PersistentIpInterface::Server
    : public virtual ::capnp::Capability::Server,
      public virtual  ::sandstorm::IpInterface::Server,
      public virtual  ::sandstorm::SystemPersistent::Server {
public:
  typedef PersistentIpInterface Serves;

  ::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:

  inline  ::sandstorm::PersistentIpInterface::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::sandstorm::PersistentIpInterface>();
  }

  ::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

// =======================================================================================

#if !CAPNP_LITE
inline IpNetwork::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline IpNetwork::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline IpNetwork::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline IpNetwork::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline IpNetwork::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::sandstorm::IpNetwork::Client& IpNetwork::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::sandstorm::IpNetwork::Client& IpNetwork::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool IpNetwork::GetRemoteHostParams::Reader::hasAddress() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool IpNetwork::GetRemoteHostParams::Builder::hasAddress() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::sandstorm::IpAddress::Reader IpNetwork::GetRemoteHostParams::Reader::getAddress() const {
  return ::capnp::_::PointerHelpers< ::sandstorm::IpAddress>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::sandstorm::IpAddress::Builder IpNetwork::GetRemoteHostParams::Builder::getAddress() {
  return ::capnp::_::PointerHelpers< ::sandstorm::IpAddress>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::sandstorm::IpAddress::Pipeline IpNetwork::GetRemoteHostParams::Pipeline::getAddress() {
  return  ::sandstorm::IpAddress::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void IpNetwork::GetRemoteHostParams::Builder::setAddress( ::sandstorm::IpAddress::Reader value) {
  ::capnp::_::PointerHelpers< ::sandstorm::IpAddress>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::sandstorm::IpAddress::Builder IpNetwork::GetRemoteHostParams::Builder::initAddress() {
  return ::capnp::_::PointerHelpers< ::sandstorm::IpAddress>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void IpNetwork::GetRemoteHostParams::Builder::adoptAddress(
    ::capnp::Orphan< ::sandstorm::IpAddress>&& value) {
  ::capnp::_::PointerHelpers< ::sandstorm::IpAddress>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::sandstorm::IpAddress> IpNetwork::GetRemoteHostParams::Builder::disownAddress() {
  return ::capnp::_::PointerHelpers< ::sandstorm::IpAddress>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool IpNetwork::GetRemoteHostResults::Reader::hasHost() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool IpNetwork::GetRemoteHostResults::Builder::hasHost() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::sandstorm::IpRemoteHost::Client IpNetwork::GetRemoteHostResults::Reader::getHost() const {
  return ::capnp::_::PointerHelpers< ::sandstorm::IpRemoteHost>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::sandstorm::IpRemoteHost::Client IpNetwork::GetRemoteHostResults::Builder::getHost() {
  return ::capnp::_::PointerHelpers< ::sandstorm::IpRemoteHost>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::sandstorm::IpRemoteHost::Client IpNetwork::GetRemoteHostResults::Pipeline::getHost() {
  return  ::sandstorm::IpRemoteHost::Client(_typeless.getPointerField(0).asCap());
}
inline void IpNetwork::GetRemoteHostResults::Builder::setHost( ::sandstorm::IpRemoteHost::Client&& cap) {
  ::capnp::_::PointerHelpers< ::sandstorm::IpRemoteHost>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(cap));
}
inline void IpNetwork::GetRemoteHostResults::Builder::setHost( ::sandstorm::IpRemoteHost::Client& cap) {
  ::capnp::_::PointerHelpers< ::sandstorm::IpRemoteHost>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), cap);
}
inline void IpNetwork::GetRemoteHostResults::Builder::adoptHost(
    ::capnp::Orphan< ::sandstorm::IpRemoteHost>&& value) {
  ::capnp::_::PointerHelpers< ::sandstorm::IpRemoteHost>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::sandstorm::IpRemoteHost> IpNetwork::GetRemoteHostResults::Builder::disownHost() {
  return ::capnp::_::PointerHelpers< ::sandstorm::IpRemoteHost>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool IpNetwork::GetRemoteHostByNameParams::Reader::hasAddress() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool IpNetwork::GetRemoteHostByNameParams::Builder::hasAddress() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader IpNetwork::GetRemoteHostByNameParams::Reader::getAddress() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder IpNetwork::GetRemoteHostByNameParams::Builder::getAddress() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void IpNetwork::GetRemoteHostByNameParams::Builder::setAddress( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder IpNetwork::GetRemoteHostByNameParams::Builder::initAddress(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void IpNetwork::GetRemoteHostByNameParams::Builder::adoptAddress(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> IpNetwork::GetRemoteHostByNameParams::Builder::disownAddress() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool IpNetwork::GetRemoteHostByNameResults::Reader::hasHost() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool IpNetwork::GetRemoteHostByNameResults::Builder::hasHost() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::sandstorm::IpRemoteHost::Client IpNetwork::GetRemoteHostByNameResults::Reader::getHost() const {
  return ::capnp::_::PointerHelpers< ::sandstorm::IpRemoteHost>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::sandstorm::IpRemoteHost::Client IpNetwork::GetRemoteHostByNameResults::Builder::getHost() {
  return ::capnp::_::PointerHelpers< ::sandstorm::IpRemoteHost>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::sandstorm::IpRemoteHost::Client IpNetwork::GetRemoteHostByNameResults::Pipeline::getHost() {
  return  ::sandstorm::IpRemoteHost::Client(_typeless.getPointerField(0).asCap());
}
inline void IpNetwork::GetRemoteHostByNameResults::Builder::setHost( ::sandstorm::IpRemoteHost::Client&& cap) {
  ::capnp::_::PointerHelpers< ::sandstorm::IpRemoteHost>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(cap));
}
inline void IpNetwork::GetRemoteHostByNameResults::Builder::setHost( ::sandstorm::IpRemoteHost::Client& cap) {
  ::capnp::_::PointerHelpers< ::sandstorm::IpRemoteHost>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), cap);
}
inline void IpNetwork::GetRemoteHostByNameResults::Builder::adoptHost(
    ::capnp::Orphan< ::sandstorm::IpRemoteHost>&& value) {
  ::capnp::_::PointerHelpers< ::sandstorm::IpRemoteHost>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::sandstorm::IpRemoteHost> IpNetwork::GetRemoteHostByNameResults::Builder::disownHost() {
  return ::capnp::_::PointerHelpers< ::sandstorm::IpRemoteHost>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline  ::uint64_t IpAddress::Reader::getLower64() const {
  return _reader.getDataField< ::uint64_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint64_t IpAddress::Builder::getLower64() {
  return _builder.getDataField< ::uint64_t>(
      0 * ::capnp::ELEMENTS);
}
inline void IpAddress::Builder::setLower64( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t IpAddress::Reader::getUpper64() const {
  return _reader.getDataField< ::uint64_t>(
      1 * ::capnp::ELEMENTS);
}

inline  ::uint64_t IpAddress::Builder::getUpper64() {
  return _builder.getDataField< ::uint64_t>(
      1 * ::capnp::ELEMENTS);
}
inline void IpAddress::Builder::setUpper64( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      1 * ::capnp::ELEMENTS, value);
}

#if !CAPNP_LITE
inline IpInterface::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline IpInterface::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline IpInterface::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline IpInterface::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline IpInterface::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::sandstorm::IpInterface::Client& IpInterface::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::sandstorm::IpInterface::Client& IpInterface::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline  ::uint16_t IpInterface::ListenTcpParams::Reader::getPortNum() const {
  return _reader.getDataField< ::uint16_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint16_t IpInterface::ListenTcpParams::Builder::getPortNum() {
  return _builder.getDataField< ::uint16_t>(
      0 * ::capnp::ELEMENTS);
}
inline void IpInterface::ListenTcpParams::Builder::setPortNum( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool IpInterface::ListenTcpParams::Reader::hasPort() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool IpInterface::ListenTcpParams::Builder::hasPort() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::sandstorm::TcpPort::Client IpInterface::ListenTcpParams::Reader::getPort() const {
  return ::capnp::_::PointerHelpers< ::sandstorm::TcpPort>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::sandstorm::TcpPort::Client IpInterface::ListenTcpParams::Builder::getPort() {
  return ::capnp::_::PointerHelpers< ::sandstorm::TcpPort>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::sandstorm::TcpPort::Client IpInterface::ListenTcpParams::Pipeline::getPort() {
  return  ::sandstorm::TcpPort::Client(_typeless.getPointerField(0).asCap());
}
inline void IpInterface::ListenTcpParams::Builder::setPort( ::sandstorm::TcpPort::Client&& cap) {
  ::capnp::_::PointerHelpers< ::sandstorm::TcpPort>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(cap));
}
inline void IpInterface::ListenTcpParams::Builder::setPort( ::sandstorm::TcpPort::Client& cap) {
  ::capnp::_::PointerHelpers< ::sandstorm::TcpPort>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), cap);
}
inline void IpInterface::ListenTcpParams::Builder::adoptPort(
    ::capnp::Orphan< ::sandstorm::TcpPort>&& value) {
  ::capnp::_::PointerHelpers< ::sandstorm::TcpPort>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::sandstorm::TcpPort> IpInterface::ListenTcpParams::Builder::disownPort() {
  return ::capnp::_::PointerHelpers< ::sandstorm::TcpPort>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool IpInterface::ListenTcpResults::Reader::hasHandle() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool IpInterface::ListenTcpResults::Builder::hasHandle() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::sandstorm::Handle::Client IpInterface::ListenTcpResults::Reader::getHandle() const {
  return ::capnp::_::PointerHelpers< ::sandstorm::Handle>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::sandstorm::Handle::Client IpInterface::ListenTcpResults::Builder::getHandle() {
  return ::capnp::_::PointerHelpers< ::sandstorm::Handle>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::sandstorm::Handle::Client IpInterface::ListenTcpResults::Pipeline::getHandle() {
  return  ::sandstorm::Handle::Client(_typeless.getPointerField(0).asCap());
}
inline void IpInterface::ListenTcpResults::Builder::setHandle( ::sandstorm::Handle::Client&& cap) {
  ::capnp::_::PointerHelpers< ::sandstorm::Handle>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(cap));
}
inline void IpInterface::ListenTcpResults::Builder::setHandle( ::sandstorm::Handle::Client& cap) {
  ::capnp::_::PointerHelpers< ::sandstorm::Handle>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), cap);
}
inline void IpInterface::ListenTcpResults::Builder::adoptHandle(
    ::capnp::Orphan< ::sandstorm::Handle>&& value) {
  ::capnp::_::PointerHelpers< ::sandstorm::Handle>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::sandstorm::Handle> IpInterface::ListenTcpResults::Builder::disownHandle() {
  return ::capnp::_::PointerHelpers< ::sandstorm::Handle>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline  ::uint16_t IpInterface::ListenUdpParams::Reader::getPortNum() const {
  return _reader.getDataField< ::uint16_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint16_t IpInterface::ListenUdpParams::Builder::getPortNum() {
  return _builder.getDataField< ::uint16_t>(
      0 * ::capnp::ELEMENTS);
}
inline void IpInterface::ListenUdpParams::Builder::setPortNum( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool IpInterface::ListenUdpParams::Reader::hasPort() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool IpInterface::ListenUdpParams::Builder::hasPort() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::sandstorm::UdpPort::Client IpInterface::ListenUdpParams::Reader::getPort() const {
  return ::capnp::_::PointerHelpers< ::sandstorm::UdpPort>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::sandstorm::UdpPort::Client IpInterface::ListenUdpParams::Builder::getPort() {
  return ::capnp::_::PointerHelpers< ::sandstorm::UdpPort>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::sandstorm::UdpPort::Client IpInterface::ListenUdpParams::Pipeline::getPort() {
  return  ::sandstorm::UdpPort::Client(_typeless.getPointerField(0).asCap());
}
inline void IpInterface::ListenUdpParams::Builder::setPort( ::sandstorm::UdpPort::Client&& cap) {
  ::capnp::_::PointerHelpers< ::sandstorm::UdpPort>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(cap));
}
inline void IpInterface::ListenUdpParams::Builder::setPort( ::sandstorm::UdpPort::Client& cap) {
  ::capnp::_::PointerHelpers< ::sandstorm::UdpPort>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), cap);
}
inline void IpInterface::ListenUdpParams::Builder::adoptPort(
    ::capnp::Orphan< ::sandstorm::UdpPort>&& value) {
  ::capnp::_::PointerHelpers< ::sandstorm::UdpPort>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::sandstorm::UdpPort> IpInterface::ListenUdpParams::Builder::disownPort() {
  return ::capnp::_::PointerHelpers< ::sandstorm::UdpPort>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool IpInterface::ListenUdpResults::Reader::hasHandle() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool IpInterface::ListenUdpResults::Builder::hasHandle() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::sandstorm::Handle::Client IpInterface::ListenUdpResults::Reader::getHandle() const {
  return ::capnp::_::PointerHelpers< ::sandstorm::Handle>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::sandstorm::Handle::Client IpInterface::ListenUdpResults::Builder::getHandle() {
  return ::capnp::_::PointerHelpers< ::sandstorm::Handle>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::sandstorm::Handle::Client IpInterface::ListenUdpResults::Pipeline::getHandle() {
  return  ::sandstorm::Handle::Client(_typeless.getPointerField(0).asCap());
}
inline void IpInterface::ListenUdpResults::Builder::setHandle( ::sandstorm::Handle::Client&& cap) {
  ::capnp::_::PointerHelpers< ::sandstorm::Handle>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(cap));
}
inline void IpInterface::ListenUdpResults::Builder::setHandle( ::sandstorm::Handle::Client& cap) {
  ::capnp::_::PointerHelpers< ::sandstorm::Handle>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), cap);
}
inline void IpInterface::ListenUdpResults::Builder::adoptHandle(
    ::capnp::Orphan< ::sandstorm::Handle>&& value) {
  ::capnp::_::PointerHelpers< ::sandstorm::Handle>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::sandstorm::Handle> IpInterface::ListenUdpResults::Builder::disownHandle() {
  return ::capnp::_::PointerHelpers< ::sandstorm::Handle>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
inline IpRemoteHost::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline IpRemoteHost::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline IpRemoteHost::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline IpRemoteHost::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline IpRemoteHost::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::sandstorm::IpRemoteHost::Client& IpRemoteHost::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::sandstorm::IpRemoteHost::Client& IpRemoteHost::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline  ::uint16_t IpRemoteHost::GetTcpPortParams::Reader::getPortNum() const {
  return _reader.getDataField< ::uint16_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint16_t IpRemoteHost::GetTcpPortParams::Builder::getPortNum() {
  return _builder.getDataField< ::uint16_t>(
      0 * ::capnp::ELEMENTS);
}
inline void IpRemoteHost::GetTcpPortParams::Builder::setPortNum( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool IpRemoteHost::GetTcpPortResults::Reader::hasPort() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool IpRemoteHost::GetTcpPortResults::Builder::hasPort() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::sandstorm::TcpPort::Client IpRemoteHost::GetTcpPortResults::Reader::getPort() const {
  return ::capnp::_::PointerHelpers< ::sandstorm::TcpPort>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::sandstorm::TcpPort::Client IpRemoteHost::GetTcpPortResults::Builder::getPort() {
  return ::capnp::_::PointerHelpers< ::sandstorm::TcpPort>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::sandstorm::TcpPort::Client IpRemoteHost::GetTcpPortResults::Pipeline::getPort() {
  return  ::sandstorm::TcpPort::Client(_typeless.getPointerField(0).asCap());
}
inline void IpRemoteHost::GetTcpPortResults::Builder::setPort( ::sandstorm::TcpPort::Client&& cap) {
  ::capnp::_::PointerHelpers< ::sandstorm::TcpPort>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(cap));
}
inline void IpRemoteHost::GetTcpPortResults::Builder::setPort( ::sandstorm::TcpPort::Client& cap) {
  ::capnp::_::PointerHelpers< ::sandstorm::TcpPort>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), cap);
}
inline void IpRemoteHost::GetTcpPortResults::Builder::adoptPort(
    ::capnp::Orphan< ::sandstorm::TcpPort>&& value) {
  ::capnp::_::PointerHelpers< ::sandstorm::TcpPort>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::sandstorm::TcpPort> IpRemoteHost::GetTcpPortResults::Builder::disownPort() {
  return ::capnp::_::PointerHelpers< ::sandstorm::TcpPort>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline  ::uint16_t IpRemoteHost::GetUdpPortParams::Reader::getPortNum() const {
  return _reader.getDataField< ::uint16_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint16_t IpRemoteHost::GetUdpPortParams::Builder::getPortNum() {
  return _builder.getDataField< ::uint16_t>(
      0 * ::capnp::ELEMENTS);
}
inline void IpRemoteHost::GetUdpPortParams::Builder::setPortNum( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool IpRemoteHost::GetUdpPortResults::Reader::hasPort() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool IpRemoteHost::GetUdpPortResults::Builder::hasPort() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::sandstorm::UdpPort::Client IpRemoteHost::GetUdpPortResults::Reader::getPort() const {
  return ::capnp::_::PointerHelpers< ::sandstorm::UdpPort>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::sandstorm::UdpPort::Client IpRemoteHost::GetUdpPortResults::Builder::getPort() {
  return ::capnp::_::PointerHelpers< ::sandstorm::UdpPort>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::sandstorm::UdpPort::Client IpRemoteHost::GetUdpPortResults::Pipeline::getPort() {
  return  ::sandstorm::UdpPort::Client(_typeless.getPointerField(0).asCap());
}
inline void IpRemoteHost::GetUdpPortResults::Builder::setPort( ::sandstorm::UdpPort::Client&& cap) {
  ::capnp::_::PointerHelpers< ::sandstorm::UdpPort>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(cap));
}
inline void IpRemoteHost::GetUdpPortResults::Builder::setPort( ::sandstorm::UdpPort::Client& cap) {
  ::capnp::_::PointerHelpers< ::sandstorm::UdpPort>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), cap);
}
inline void IpRemoteHost::GetUdpPortResults::Builder::adoptPort(
    ::capnp::Orphan< ::sandstorm::UdpPort>&& value) {
  ::capnp::_::PointerHelpers< ::sandstorm::UdpPort>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::sandstorm::UdpPort> IpRemoteHost::GetUdpPortResults::Builder::disownPort() {
  return ::capnp::_::PointerHelpers< ::sandstorm::UdpPort>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
inline TcpPort::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline TcpPort::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline TcpPort::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline TcpPort::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline TcpPort::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::sandstorm::TcpPort::Client& TcpPort::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::sandstorm::TcpPort::Client& TcpPort::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool TcpPort::ConnectParams::Reader::hasDownstream() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool TcpPort::ConnectParams::Builder::hasDownstream() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::sandstorm::ByteStream::Client TcpPort::ConnectParams::Reader::getDownstream() const {
  return ::capnp::_::PointerHelpers< ::sandstorm::ByteStream>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::sandstorm::ByteStream::Client TcpPort::ConnectParams::Builder::getDownstream() {
  return ::capnp::_::PointerHelpers< ::sandstorm::ByteStream>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::sandstorm::ByteStream::Client TcpPort::ConnectParams::Pipeline::getDownstream() {
  return  ::sandstorm::ByteStream::Client(_typeless.getPointerField(0).asCap());
}
inline void TcpPort::ConnectParams::Builder::setDownstream( ::sandstorm::ByteStream::Client&& cap) {
  ::capnp::_::PointerHelpers< ::sandstorm::ByteStream>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(cap));
}
inline void TcpPort::ConnectParams::Builder::setDownstream( ::sandstorm::ByteStream::Client& cap) {
  ::capnp::_::PointerHelpers< ::sandstorm::ByteStream>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), cap);
}
inline void TcpPort::ConnectParams::Builder::adoptDownstream(
    ::capnp::Orphan< ::sandstorm::ByteStream>&& value) {
  ::capnp::_::PointerHelpers< ::sandstorm::ByteStream>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::sandstorm::ByteStream> TcpPort::ConnectParams::Builder::disownDownstream() {
  return ::capnp::_::PointerHelpers< ::sandstorm::ByteStream>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline bool TcpPort::ConnectResults::Reader::hasUpstream() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool TcpPort::ConnectResults::Builder::hasUpstream() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::sandstorm::ByteStream::Client TcpPort::ConnectResults::Reader::getUpstream() const {
  return ::capnp::_::PointerHelpers< ::sandstorm::ByteStream>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::sandstorm::ByteStream::Client TcpPort::ConnectResults::Builder::getUpstream() {
  return ::capnp::_::PointerHelpers< ::sandstorm::ByteStream>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::sandstorm::ByteStream::Client TcpPort::ConnectResults::Pipeline::getUpstream() {
  return  ::sandstorm::ByteStream::Client(_typeless.getPointerField(0).asCap());
}
inline void TcpPort::ConnectResults::Builder::setUpstream( ::sandstorm::ByteStream::Client&& cap) {
  ::capnp::_::PointerHelpers< ::sandstorm::ByteStream>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(cap));
}
inline void TcpPort::ConnectResults::Builder::setUpstream( ::sandstorm::ByteStream::Client& cap) {
  ::capnp::_::PointerHelpers< ::sandstorm::ByteStream>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), cap);
}
inline void TcpPort::ConnectResults::Builder::adoptUpstream(
    ::capnp::Orphan< ::sandstorm::ByteStream>&& value) {
  ::capnp::_::PointerHelpers< ::sandstorm::ByteStream>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::sandstorm::ByteStream> TcpPort::ConnectResults::Builder::disownUpstream() {
  return ::capnp::_::PointerHelpers< ::sandstorm::ByteStream>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
inline UdpPort::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline UdpPort::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline UdpPort::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline UdpPort::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline UdpPort::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::sandstorm::UdpPort::Client& UdpPort::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::sandstorm::UdpPort::Client& UdpPort::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool UdpPort::SendParams::Reader::hasMessage() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool UdpPort::SendParams::Builder::hasMessage() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader UdpPort::SendParams::Reader::getMessage() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder UdpPort::SendParams::Builder::getMessage() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void UdpPort::SendParams::Builder::setMessage( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder UdpPort::SendParams::Builder::initMessage(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void UdpPort::SendParams::Builder::adoptMessage(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> UdpPort::SendParams::Builder::disownMessage() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

inline bool UdpPort::SendParams::Reader::hasReturnPort() const {
  return !_reader.getPointerField(1 * ::capnp::POINTERS).isNull();
}
inline bool UdpPort::SendParams::Builder::hasReturnPort() {
  return !_builder.getPointerField(1 * ::capnp::POINTERS).isNull();
}
#if !CAPNP_LITE
inline  ::sandstorm::UdpPort::Client UdpPort::SendParams::Reader::getReturnPort() const {
  return ::capnp::_::PointerHelpers< ::sandstorm::UdpPort>::get(
      _reader.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::sandstorm::UdpPort::Client UdpPort::SendParams::Builder::getReturnPort() {
  return ::capnp::_::PointerHelpers< ::sandstorm::UdpPort>::get(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
inline  ::sandstorm::UdpPort::Client UdpPort::SendParams::Pipeline::getReturnPort() {
  return  ::sandstorm::UdpPort::Client(_typeless.getPointerField(1).asCap());
}
inline void UdpPort::SendParams::Builder::setReturnPort( ::sandstorm::UdpPort::Client&& cap) {
  ::capnp::_::PointerHelpers< ::sandstorm::UdpPort>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(cap));
}
inline void UdpPort::SendParams::Builder::setReturnPort( ::sandstorm::UdpPort::Client& cap) {
  ::capnp::_::PointerHelpers< ::sandstorm::UdpPort>::set(
      _builder.getPointerField(1 * ::capnp::POINTERS), cap);
}
inline void UdpPort::SendParams::Builder::adoptReturnPort(
    ::capnp::Orphan< ::sandstorm::UdpPort>&& value) {
  ::capnp::_::PointerHelpers< ::sandstorm::UdpPort>::adopt(
      _builder.getPointerField(1 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::sandstorm::UdpPort> UdpPort::SendParams::Builder::disownReturnPort() {
  return ::capnp::_::PointerHelpers< ::sandstorm::UdpPort>::disown(
      _builder.getPointerField(1 * ::capnp::POINTERS));
}
#endif  // !CAPNP_LITE

inline  ::uint16_t IpPortPowerboxMetadata::Reader::getPreferredPortNum() const {
  return _reader.getDataField< ::uint16_t>(
      0 * ::capnp::ELEMENTS);
}

inline  ::uint16_t IpPortPowerboxMetadata::Builder::getPreferredPortNum() {
  return _builder.getDataField< ::uint16_t>(
      0 * ::capnp::ELEMENTS);
}
inline void IpPortPowerboxMetadata::Builder::setPreferredPortNum( ::uint16_t value) {
  _builder.setDataField< ::uint16_t>(
      0 * ::capnp::ELEMENTS, value);
}

inline bool IpPortPowerboxMetadata::Reader::hasPreferredHost() const {
  return !_reader.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline bool IpPortPowerboxMetadata::Builder::hasPreferredHost() {
  return !_builder.getPointerField(0 * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader IpPortPowerboxMetadata::Reader::getPreferredHost() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _reader.getPointerField(0 * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder IpPortPowerboxMetadata::Builder::getPreferredHost() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}
inline void IpPortPowerboxMetadata::Builder::setPreferredHost( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(
      _builder.getPointerField(0 * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder IpPortPowerboxMetadata::Builder::initPreferredHost(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(
      _builder.getPointerField(0 * ::capnp::POINTERS), size);
}
inline void IpPortPowerboxMetadata::Builder::adoptPreferredHost(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(
      _builder.getPointerField(0 * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> IpPortPowerboxMetadata::Builder::disownPreferredHost() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(
      _builder.getPointerField(0 * ::capnp::POINTERS));
}

#if !CAPNP_LITE
inline PersistentIpNetwork::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline PersistentIpNetwork::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline PersistentIpNetwork::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline PersistentIpNetwork::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline PersistentIpNetwork::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::sandstorm::PersistentIpNetwork::Client& PersistentIpNetwork::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::sandstorm::PersistentIpNetwork::Client& PersistentIpNetwork::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
#if !CAPNP_LITE
inline PersistentIpInterface::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline PersistentIpInterface::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline PersistentIpInterface::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline PersistentIpInterface::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline PersistentIpInterface::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::sandstorm::PersistentIpInterface::Client& PersistentIpInterface::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::sandstorm::PersistentIpInterface::Client& PersistentIpInterface::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
}  // namespace

#endif  // CAPNP_INCLUDED_f44732d435305f86_
